<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MagiWolf Quest</title>
  <style>
    :root {
      --sky: #8cc9ff;
      --ink: #1c1a23;
      --wood: #9b5b2f;
      --stone: #6c7a89;
      --gold: #f5c542;
      --rune: #6f9bff;
      --wand: #c07bff;
      --pet: #59c29a;
      --danger: #ff6b6b;
      --panel: rgba(20, 20, 28, 0.78);
      --panel-light: rgba(255, 255, 255, 0.1);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at top, #dff2ff, #9bd1ff 40%, #6fa6ff 100%);
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }
    #game-wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
    }
    canvas {
      width: min(100vw, 1024px);
      height: min(100vh, 576px);
      border-radius: 18px;
      box-shadow: 0 24px 60px rgba(20, 22, 36, 0.45);
      background: #11141f;
      image-rendering: crisp-edges;
      touch-action: none;
    }
    #hud {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 18px;
      align-items: center;
      padding: 10px 16px;
      border-radius: 14px;
      background: var(--panel);
      border: 1px solid var(--panel-light);
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 1px;
      z-index: 5;
    }
    .hud-block {
      display: grid;
      gap: 4px;
      align-items: center;
      justify-items: center;
      min-width: 90px;
    }
    .hud-title {
      font-size: 11px;
      color: #d8e7ff;
    }
    .hud-value {
      font-size: 11px;
      color: #ffffff;
    }
    .icon-row {
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: center;
    }
    .icon {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      display: grid;
      place-items: center;
      font-size: 12px;
      font-weight: 700;
      color: #111;
    }
    .icon.heart { background: #ff7e88; }
    .icon.rune { background: var(--rune); }
    .icon.key { background: var(--gold); }
    .icon.wand { background: var(--wand); }
    .icon.pet { background: var(--pet); }
    #dialog, #quiz, #pause, #title, #victory {
      position: absolute;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(10, 12, 20, 0.55);
      z-index: 10;
    }
    .panel {
      width: min(760px, 92vw);
      background: var(--panel);
      border: 1px solid var(--panel-light);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 20px 50px rgba(5, 8, 20, 0.6);
    }
    .panel h2 {
      margin: 0 0 12px 0;
      font-size: 24px;
      letter-spacing: 1px;
    }
    .panel p {
      margin: 8px 0;
      line-height: 1.4;
      color: #e4eefc;
    }
    .choice-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    .choice {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 12px 14px;
      border-radius: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease, background 0.15s ease;
    }
    .choice:hover { transform: translateY(-2px); background: rgba(255, 255, 255, 0.16); }
    .choice span.badge {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      background: #5bc0ff;
      color: #04172f;
      font-weight: 700;
      display: grid;
      place-items: center;
    }
    #title .panel, #victory .panel { text-align: center; }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    button {
      background: #f6c96c;
      border: none;
      border-radius: 999px;
      padding: 10px 20px;
      font-weight: 700;
      cursor: pointer;
      color: #3b2400;
      letter-spacing: 0.5px;
    }
    button.secondary { background: #8bd1ff; }
    #corner-note {
      position: absolute;
      bottom: 16px;
      right: 20px;
      font-size: 11px;
      color: #dfe8ff;
      opacity: 0.7;
      z-index: 4;
    }
    #touch-controls {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: none;
      z-index: 12;
      padding: 0 env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      --touch-raise: 48px;
    }
    .touch-cluster {
      position: absolute;
      bottom: calc(18px + env(safe-area-inset-bottom) + var(--touch-raise));
      display: grid;
      gap: 12px;
      pointer-events: auto;
    }
    .touch-left {
      left: calc(18px + env(safe-area-inset-left));
      grid-template-columns: repeat(2, 64px);
    }
    .touch-right {
      right: calc(18px + env(safe-area-inset-right));
      grid-template-columns: repeat(2, 64px);
      bottom: calc(56px + env(safe-area-inset-bottom) + var(--touch-raise));
    }
    .touch-btn {
      width: clamp(56px, 10vw, 72px);
      height: clamp(56px, 10vw, 72px);
      border-radius: 18px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(20, 20, 28, 0.55);
      color: #fff;
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 1px;
      display: grid;
      place-items: center;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      user-select: none;
      touch-action: none;
    }
    .touch-btn:active {
      transform: translateY(1px);
      background: rgba(255, 210, 140, 0.45);
      color: #2a1f3d;
    }
    .touch-mini {
      position: absolute;
      top: calc(16px + env(safe-area-inset-top));
      right: calc(18px + env(safe-area-inset-right));
      display: grid;
      gap: 8px;
      pointer-events: auto;
    }
    .touch-mini .touch-btn {
      width: 52px;
      height: 52px;
      border-radius: 14px;
      font-size: 12px;
    }
    .joystick {
      width: clamp(110px, 22vw, 160px);
      height: clamp(110px, 22vw, 160px);
      border-radius: 50%;
      background: rgba(20, 20, 28, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.25);
      display: grid;
      place-items: center;
      touch-action: none;
      position: relative;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
    }
    .joystick-knob {
      width: clamp(44px, 9vw, 64px);
      height: clamp(44px, 9vw, 64px);
      border-radius: 50%;
      background: rgba(255, 210, 140, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.6);
      box-shadow: inset 0 4px 10px rgba(255, 255, 255, 0.2);
      transform: translate(0, 0);
    }
    @media (max-width: 720px) {
      canvas {
        width: 100vw;
        height: 100vh;
        max-height: 100vh;
        border-radius: 0;
      }
      #hud {
        top: 8px;
        gap: 10px;
        padding: 8px 10px;
        font-size: 10px;
      }
      .hud-block { min-width: 70px; }
      .choice {
        font-size: 16px;
        padding: 16px 14px;
      }
    }
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="game" width="1024" height="576"></canvas>
    <div id="hud">
      <div class="hud-block">
        <div class="hud-title">Magi Alastair</div>
        <div id="scene-name">Title</div>
      </div>
      <div class="hud-block">
        <div class="hud-title">Hearts</div>
        <div class="icon-row" id="hearts"></div>
        <div class="hud-value" id="hearts-value"></div>
      </div>
      <div class="hud-block">
        <div class="hud-title">Runes</div>
        <div class="icon-row" id="runes"></div>
        <div class="hud-value" id="runes-value"></div>
      </div>
      <div class="hud-block">
        <div class="hud-title">Key</div>
        <div class="icon-row" id="key"></div>
        <div class="hud-value" id="key-value"></div>
      </div>
      <div class="hud-block">
        <div class="hud-title">Wand</div>
        <div class="icon-row" id="wand"></div>
        <div class="hud-value" id="wand-value"></div>
      </div>
      <div class="hud-block">
        <div class="hud-title">Pet</div>
        <div class="icon-row" id="pet"></div>
        <div class="hud-value" id="pet-value"></div>
      </div>
    </div>
    <div id="dialog"><div class="panel"><h2 id="dialog-title"></h2><p id="dialog-body"></p><p><strong>Press E</strong> to continue.</p></div></div>
    <div id="quiz"><div class="panel"><h2 id="quiz-title">Gate Quiz</h2><p id="quiz-body"></p><div class="choice-grid" id="quiz-choices"></div><p><strong>Use keys 1-4.</strong></p></div></div>
    <div id="pause"><div class="panel"><h2>Paused</h2><p>Press P to resume.</p></div></div>
    <div id="title"><div class="panel"><h2>MagiWolf Quest</h2><p>Help Magi Alastair collect runes, a key, and a wand to unlock the Magi Tower.</p><p>Move: A/D or Arrows. Jump: Space/W/Up. Interact: E. Pause: P.</p><div class="btn-row"><button id="start-btn">New Adventure</button><button id="continue-btn" class="secondary">Continue</button></div></div></div>
    <div id="victory"><div class="panel"><h2>Victory!</h2><p>The tower awakens. Magi Alastair has proven their courage and kindness.</p><div class="btn-row"><button id="restart-btn">Play Again</button></div></div></div>
    <div id="touch-controls">
      <div class="touch-cluster touch-left">
        <div class="joystick" id="joystick">
          <div class="joystick-knob" id="joystick-knob"></div>
        </div>
      </div>
      <div class="touch-cluster touch-right">
        <div class="touch-btn" data-action="jump">JUMP</div>
        <div class="touch-btn" data-action="interact">E</div>
      </div>
      <div class="touch-mini">
        <div class="touch-btn" data-action="pause">P</div>
      </div>
    </div>
    <div id="corner-note">M1 prototype build</div>
  </div>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const hud = {
      scene: document.getElementById("scene-name"),
      hearts: document.getElementById("hearts"),
      runes: document.getElementById("runes"),
      key: document.getElementById("key"),
      wand: document.getElementById("wand"),
      pet: document.getElementById("pet"),
      heartsValue: document.getElementById("hearts-value"),
      runesValue: document.getElementById("runes-value"),
      keyValue: document.getElementById("key-value"),
      wandValue: document.getElementById("wand-value"),
      petValue: document.getElementById("pet-value")
    };

    const overlays = {
      dialog: document.getElementById("dialog"),
      dialogTitle: document.getElementById("dialog-title"),
      dialogBody: document.getElementById("dialog-body"),
      quiz: document.getElementById("quiz"),
      quizBody: document.getElementById("quiz-body"),
      quizChoices: document.getElementById("quiz-choices"),
      pause: document.getElementById("pause"),
      title: document.getElementById("title"),
      victory: document.getElementById("victory"),
      start: document.getElementById("start-btn"),
      continue: document.getElementById("continue-btn"),
      restart: document.getElementById("restart-btn")
    };
    const touchControls = document.getElementById("touch-controls");
    const joystick = document.getElementById("joystick");
    const joystickKnob = document.getElementById("joystick-knob");

    const INPUT = { left: false, right: false, up: false, interact: false };

    const KEYMAP = {
      ArrowLeft: "left", ArrowRight: "right", ArrowUp: "up",
      a: "left", d: "right", w: "up"
    };

    const game = {
      scene: "Title",
      player: null,
      inventory: { runes: 0, key: false, wand: false },
      hearts: 3,
      pet: null,
      gateStates: { lobby: false, water: false, tower: false },
      dialogQueue: [],
      dialogActive: false,
      quizActive: false,
      paused: false,
      camera: { x: 0, y: 0 },
      lastCheckpoint: null,
      lastTick: 0,
      touchAxisX: 0,
      invuln: 0
    };

    const PETS = {
      pinePup: {
        id: "pinePup",
        name: "Pine Pup",
        graceBonus: 0.12
      }
    };

    const SCENES = {
      Title: { name: "Title" },
      "Lodge Lobby": {
        name: "Lodge Lobby",
        width: 1600,
        height: 576,
        background: { top: "#cfe9ff", bottom: "#78b7ff" },
        platforms: [
          { x: 0, y: 500, w: 1600, h: 76, type: "ground" },
          { x: 280, y: 420, w: 180, h: 22, type: "wood" },
          { x: 560, y: 360, w: 200, h: 22, type: "wood" },
          { x: 880, y: 310, w: 160, h: 22, type: "wood" }
        ],
        runes: [
          { x: 330, y: 380, collected: false },
          { x: 640, y: 320, collected: false },
          { x: 940, y: 270, collected: false }
        ],
        gates: [
          { id: "lobby", x: 1400, y: 350, w: 90, h: 150, label: "Rune Gate" }
        ],
        dialogs: [
          { x: 140, y: 430, w: 80, h: 80, title: "Caretaker", text: "Collect three glowing runes. The gate will ask a quick addition question." }
        ],
        exits: [
          { x: 1500, y: 350, w: 80, h: 150, target: "Water Park", spawn: { x: 60, y: 420 } }
        ]
      },
      "Water Park": {
        name: "Water Park",
        width: 1800,
        height: 576,
        background: { top: "#bfe9ff", bottom: "#5db4ff" },
        platforms: [
          { x: 0, y: 510, w: 1800, h: 66, type: "ground" },
          { x: 240, y: 420, w: 200, h: 18, type: "stone" },
          { x: 560, y: 360, w: 220, h: 18, type: "stone" },
          { x: 920, y: 310, w: 220, h: 18, type: "stone" },
          { x: 1240, y: 260, w: 200, h: 18, type: "stone" }
        ],
        hazards: [
          { x: 420, y: 470, w: 60, h: 20, vx: 80 },
          { x: 760, y: 470, w: 60, h: 20, vx: -100 }
        ],
        enemies: [
          { x: 520, y: 468, w: 32, h: 32, vx: 50, minX: 420, maxX: 720 }
        ],
        keyItem: { x: 1320, y: 220, collected: false },
        gates: [
          { id: "water", x: 1640, y: 350, w: 90, h: 150, label: "Key Gate" }
        ],
        dialogs: [
          { x: 120, y: 440, w: 90, h: 60, title: "Lifeguard", text: "Watch the floaters. Grab the golden key near the slides." }
        ],
        exits: [
          { x: 1700, y: 350, w: 80, h: 150, target: "Forest Trail", spawn: { x: 60, y: 420 } }
        ]
      },
      "Forest Trail": {
        name: "Forest Trail",
        width: 1800,
        height: 576,
        background: { top: "#bfe8d0", bottom: "#59ad7a" },
        platforms: [
          { x: 0, y: 510, w: 1800, h: 66, type: "ground" },
          { x: 280, y: 410, w: 200, h: 20, type: "wood" },
          { x: 620, y: 350, w: 200, h: 20, type: "wood" },
          { x: 980, y: 300, w: 200, h: 20, type: "wood" }
        ],
        checkpoints: [
          { id: "trail-1", x: 260, y: 450, w: 50, h: 60 },
          { id: "trail-2", x: 980, y: 450, w: 50, h: 60 }
        ],
        enemies: [
          { x: 420, y: 468, w: 34, h: 34, vx: 45, minX: 320, maxX: 620 }
        ],
        petSpot: { x: 680, y: 310, w: 60, h: 60, prompted: false },
        dialogs: [
          { x: 120, y: 440, w: 90, h: 60, title: "Forest Spirit", text: "A Pine Pup waits ahead. Press E to befriend it." }
        ],
        exits: [
          { x: 1700, y: 350, w: 80, h: 150, target: "Magi Tower", spawn: { x: 60, y: 420 } }
        ]
      },
      "Magi Tower": {
        name: "Magi Tower",
        width: 1600,
        height: 576,
        background: { top: "#e2d5ff", bottom: "#7f6fc1" },
        platforms: [
          { x: 0, y: 510, w: 1600, h: 66, type: "ground" },
          { x: 260, y: 420, w: 200, h: 20, type: "stone" },
          { x: 600, y: 360, w: 200, h: 20, type: "stone" },
          { x: 920, y: 300, w: 200, h: 20, type: "stone" }
        ],
        wandItem: { x: 980, y: 260, collected: false },
        enemies: [
          { x: 320, y: 468, w: 36, h: 36, vx: 55, minX: 260, maxX: 520 },
          { x: 760, y: 468, w: 36, h: 36, vx: -55, minX: 640, maxX: 980 }
        ],
        gates: [
          { id: "tower", x: 1380, y: 350, w: 90, h: 150, label: "Tower Gate" }
        ],
        dialogs: [
          { x: 120, y: 440, w: 90, h: 60, title: "Tower Guide", text: "The wand is above. The final gate checks a quick multiplication." }
        ],
        exits: [
          { x: 1500, y: 350, w: 80, h: 150, target: "Victory", spawn: { x: 100, y: 420 } }
        ]
      },
      Victory: {
        name: "Victory",
        width: 1024,
        height: 576,
        background: { top: "#fff3c8", bottom: "#f7b76b" },
        platforms: [ { x: 0, y: 510, w: 1024, h: 66, type: "ground" } ],
        dialogs: []
      }
    };
    function rectsOverlap(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }

    function createPlayer(spawn) {
      return {
        x: spawn.x,
        y: spawn.y,
        w: 36,
        h: 52,
        vx: 0,
        vy: 0,
        speed: 280,
        jumpPower: 720,
        gravity: 2200,
        onGround: false,
        coyote: 0,
        jumpBuffer: 0
      };
    }

    function setHUD() {
      hud.scene.textContent = game.scene || "?";
      hud.hearts.innerHTML = "";
      for (let i = 0; i < game.hearts; i += 1) {
        const el = document.createElement("div");
        el.className = "icon heart";
        el.textContent = "H";
        hud.hearts.appendChild(el);
      }
      hud.heartsValue.textContent = `${game.hearts}/3`;
      hud.runes.innerHTML = "";
      for (let i = 0; i < 3; i += 1) {
        const el = document.createElement("div");
        el.className = "icon rune";
        el.style.opacity = i < game.inventory.runes ? "1" : "0.25";
        el.textContent = "*";
        hud.runes.appendChild(el);
      }
      hud.runesValue.textContent = `${game.inventory.runes}/3`;
      hud.key.innerHTML = "";
      const keyEl = document.createElement("div");
      keyEl.className = "icon key";
      keyEl.style.opacity = game.inventory.key ? "1" : "0.25";
      keyEl.textContent = "K";
      hud.key.appendChild(keyEl);
      hud.keyValue.textContent = game.inventory.key ? "Yes" : "No";
      hud.wand.innerHTML = "";
      const wandEl = document.createElement("div");
      wandEl.className = "icon wand";
      wandEl.style.opacity = game.inventory.wand ? "1" : "0.25";
      wandEl.textContent = "W";
      hud.wand.appendChild(wandEl);
      hud.wandValue.textContent = game.inventory.wand ? "Yes" : "No";
      hud.pet.innerHTML = "";
      const petEl = document.createElement("div");
      petEl.className = "icon pet";
      petEl.style.opacity = game.pet ? "1" : "0.25";
      petEl.textContent = game.pet ? "P" : "-";
      hud.pet.appendChild(petEl);
      hud.petValue.textContent = game.pet ? PETS[game.pet].name : "None";
    }

    function showDialog(title, body) {
      game.dialogActive = true;
      overlays.dialogTitle.textContent = title;
      overlays.dialogBody.textContent = body;
      overlays.dialog.style.display = "grid";
    }

    function quickDialog(title, body, durationMs) {
      showDialog(title, body);
      const delay = durationMs || 900;
      window.setTimeout(() => {
        if (!game.dialogActive) return;
        if (overlays.dialogTitle.textContent !== title) return;
        game.dialogActive = false;
        overlays.dialog.style.display = "none";
      }, delay);
    }

    function nextDialog() {
      if (game.dialogQueue.length === 0) {
        game.dialogActive = false;
        overlays.dialog.style.display = "none";
        return;
      }
      const item = game.dialogQueue.shift();
      showDialog(item.title, item.text);
    }

    function queueDialog(title, text) {
      game.dialogQueue.push({ title, text });
      if (!game.dialogActive) {
        nextDialog();
      }
    }

    function showQuiz(question, choices, onResult) {
      game.quizActive = true;
      overlays.quizBody.textContent = question;
      overlays.quizChoices.innerHTML = "";
      choices.forEach((choice, idx) => {
        const el = document.createElement("div");
        el.className = "choice";
        el.innerHTML = `<span class="badge">${idx + 1}</span><span>${choice}</span>`;
        el.addEventListener("click", () => onResult(idx));
        overlays.quizChoices.appendChild(el);
      });
      overlays.quiz.style.display = "grid";
      game.quizHandler = onResult;
    }

    function closeQuiz() {
      game.quizActive = false;
      overlays.quiz.style.display = "none";
    }

    function saveGame() {
      const payload = {
        scene: game.scene,
        player: { x: game.player.x, y: game.player.y },
        inventory: game.inventory,
        hearts: game.hearts,
        pet: game.pet,
        gateStates: game.gateStates,
        lastCheckpoint: game.lastCheckpoint,
        sceneState: {
          lobbyRunes: SCENES["Lodge Lobby"].runes.map(r => r.collected),
          waterKey: SCENES["Water Park"].keyItem.collected,
          towerWand: SCENES["Magi Tower"].wandItem.collected
        }
      };
      try {
        localStorage.setItem("magiwolf-save", JSON.stringify(payload));
      } catch (error) {
        // Ignore storage failures (e.g., file:// restrictions).
      }
    }

    function loadGame() {
      let raw = null;
      try {
        raw = localStorage.getItem("magiwolf-save");
      } catch (error) {
        raw = null;
      }
      if (!raw) return false;
      const data = JSON.parse(raw);
      game.scene = data.scene;
      game.inventory = data.inventory;
      game.hearts = data.hearts;
      game.pet = data.pet;
      game.gateStates = data.gateStates;
      game.lastCheckpoint = data.lastCheckpoint;
      const lobbyRunes = SCENES["Lodge Lobby"].runes;
      data.sceneState.lobbyRunes.forEach((value, idx) => lobbyRunes[idx].collected = value);
      SCENES["Water Park"].keyItem.collected = data.sceneState.waterKey;
      SCENES["Magi Tower"].wandItem.collected = data.sceneState.towerWand;
      const spawn = data.lastCheckpoint && data.lastCheckpoint.scene === data.scene
        ? data.lastCheckpoint
        : data.player;
      game.player = createPlayer({ x: spawn.x, y: spawn.y });
      return true;
    }

    function resetGame() {
      game.inventory = { runes: 0, key: false, wand: false };
      game.hearts = 3;
      game.pet = null;
      game.gateStates = { lobby: false, water: false, tower: false };
      game.lastCheckpoint = null;
      SCENES["Lodge Lobby"].runes.forEach(r => r.collected = false);
      SCENES["Water Park"].keyItem.collected = false;
      SCENES["Magi Tower"].wandItem.collected = false;
      if (SCENES["Forest Trail"].petSpot) {
        SCENES["Forest Trail"].petSpot.prompted = false;
      }
      enterScene("Lodge Lobby", { x: 100, y: 400 });
    }

    function respawn() {
      const checkpoint = game.lastCheckpoint || { scene: game.scene, x: 80, y: 420 };
      game.scene = checkpoint.scene;
      game.player = createPlayer({ x: checkpoint.x, y: checkpoint.y });
    }

    function getScene() {
      return SCENES[game.scene];
    }

    function handleGate(scene, gate) {
      if (game.gateStates[gate.id]) return;
      if (gate.id === "lobby" && game.inventory.runes < 3) {
        queueDialog("Rune Gate", "You need 3 runes to attempt the gate.");
        return;
      }
      if (gate.id === "water" && !game.inventory.key) {
        queueDialog("Key Gate", "You need the Golden Key to attempt the gate.");
        return;
      }
      if (gate.id === "tower" && !game.inventory.wand) {
        queueDialog("Tower Gate", "You need the Wand to attempt the gate.");
        return;
      }
      const quiz = createGateQuiz(gate.id);
      showQuiz(quiz.question, quiz.choices, idx => {
        if (idx === quiz.answer) {
          game.gateStates[gate.id] = true;
          closeQuiz();
          queueDialog("Gate Opened", "Great work! The gate unlocks.");
          saveGame();
        } else {
          queueDialog("Try Again", "Not quite. Pick another answer.");
        }
      });
    }

    function createGateQuiz(id) {
      if (id === "lobby") {
        const a = 2 + Math.floor(Math.random() * 5);
        const b = 2 + Math.floor(Math.random() * 5);
        const answer = a + b;
        const choices = shuffle([answer, answer + 1, answer - 1, answer + 2]);
        return {
          question: `Addition gate: ${a} + ${b} = ?`,
          choices: choices.map(n => `${n}`),
          answer: choices.indexOf(answer)
        };
      }
      if (id === "water") {
        const a = 5 + Math.floor(Math.random() * 6);
        const b = 1 + Math.floor(Math.random() * 10);
        const op = Math.random() > 0.5 ? "+" : "-";
        const answer = op === "+" ? a + b : a - b;
        const choices = shuffle([answer, answer + 2, answer - 2, answer + 4]);
        return {
          question: `Water gate: ${a} ${op} ${b} = ?`,
          choices: choices.map(n => `${n}`),
          answer: choices.indexOf(answer)
        };
      }
      const a = 2 + Math.floor(Math.random() * 4);
      const b = 2 + Math.floor(Math.random() * 4);
      const answer = a * b;
      const choices = shuffle([answer, answer + b, answer - 2, answer + 4]);
      return {
        question: `Tower gate: ${a} x ${b} = ?`,
        choices: choices.map(n => `${n}`),
        answer: choices.indexOf(answer)
      };
    }

    function shuffle(items) {
      const copy = items.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function enterScene(name, spawn) {
      game.scene = name;
      game.player = createPlayer(spawn || { x: 80, y: 420 });
      game.camera.x = 0;
      game.camera.y = 0;
      if (name === "Victory") {
        overlays.victory.style.display = "grid";
      } else {
        overlays.victory.style.display = "none";
      }
      setHUD();
    }
    function update(dt) {
      const scene = getScene();
      const player = game.player;
      const graceBase = 0.1 + (game.pet ? PETS[game.pet].graceBonus : 0);
      if (game.invuln > 0) {
        game.invuln = Math.max(0, game.invuln - dt);
      }

      player.coyote = player.onGround ? graceBase : Math.max(0, player.coyote - dt);
      player.jumpBuffer = Math.max(0, player.jumpBuffer - dt);

      const axis = game.touchAxisX !== 0 ? game.touchAxisX : (INPUT.right ? 1 : 0) + (INPUT.left ? -1 : 0);
      if (axis < -0.05) player.vx = clamp(player.vx + axis * player.speed * dt * 4, -player.speed, player.speed);
      if (axis > 0.05) player.vx = clamp(player.vx + axis * player.speed * dt * 4, -player.speed, player.speed);
      if (Math.abs(axis) <= 0.05) player.vx *= 0.85;

      if (player.jumpBuffer > 0 && player.coyote > 0) {
        player.vy = -player.jumpPower;
        player.coyote = 0;
        player.jumpBuffer = 0;
        player.onGround = false;
      }

      player.vy += player.gravity * dt;
      player.vy = clamp(player.vy, -1200, 1200);

      player.x += player.vx * dt;
      const solidRects = getSolidRects(scene);
      resolveCollisions(player, solidRects, true);

      player.y += player.vy * dt;
      player.onGround = false;
      resolveCollisions(player, solidRects, false);

      player.x = clamp(player.x, 10, scene.width - player.w - 10);

      scene.hazards && scene.hazards.forEach(hazard => {
        hazard.x += hazard.vx * dt;
        if (hazard.x < 300 || hazard.x > scene.width - 200) hazard.vx *= -1;
        if (rectsOverlap(player, hazard)) {
          takeDamage();
        }
      });

      if (scene.enemies) {
        scene.enemies.forEach(enemy => {
          if (enemy.defeated) return;
          enemy.x += enemy.vx * dt;
          if (enemy.x < enemy.minX || enemy.x > enemy.maxX) enemy.vx *= -1;
          if (rectsOverlap(player, enemy)) {
            const playerBottom = player.y + player.h;
            const enemyTop = enemy.y + 6;
            if (player.vy > 120 && playerBottom < enemyTop + 12) {
              enemy.defeated = true;
              player.vy = -player.jumpPower * 0.6;
              quickDialog("Stomp!", "Enemy cleared.", 600);
            } else {
              takeDamage();
            }
          }
        });
      }

      scene.runes && scene.runes.forEach(rune => {
        if (!rune.collected && rectsOverlap(player, { x: rune.x, y: rune.y, w: 24, h: 24 })) {
          rune.collected = true;
          game.inventory.runes += 1;
          // No dialog on rune pickup to keep flow smooth.
          saveGame();
        }
      });

      if (scene.keyItem && !scene.keyItem.collected && rectsOverlap(player, { x: scene.keyItem.x, y: scene.keyItem.y, w: 26, h: 26 })) {
        scene.keyItem.collected = true;
        game.inventory.key = true;
        quickDialog("Golden Key", "You found the Golden Key.");
        saveGame();
      }

      if (scene.wandItem && !scene.wandItem.collected && rectsOverlap(player, { x: scene.wandItem.x, y: scene.wandItem.y, w: 26, h: 26 })) {
        scene.wandItem.collected = true;
        game.inventory.wand = true;
        quickDialog("Tower Wand", "The wand hums with energy.");
        saveGame();
      }

      if (scene.checkpoints) {
        scene.checkpoints.forEach(check => {
          if (rectsOverlap(player, check)) {
            game.lastCheckpoint = { scene: game.scene, x: check.x, y: check.y - 20 };
            saveGame();
          }
        });
      }

      if (scene.petSpot && !game.pet && rectsOverlap(player, scene.petSpot) && !scene.petSpot.prompted) {
        scene.petSpot.prompted = true;
        queueDialog("Pine Pup", "Press E to befriend the Pine Pup.");
      }

      scene.exits && scene.exits.forEach(exit => {
        if (rectsOverlap(player, exit)) {
          enterScene(exit.target, exit.spawn);
        }
      });

      const camTargetX = clamp(player.x - canvas.width / 2 + player.w / 2, 0, scene.width - canvas.width);
      game.camera.x += (camTargetX - game.camera.x) * 0.08;
    }

    function resolveCollisions(player, solids, horizontal) {
      solids.forEach(rect => {
        if (rectsOverlap(player, rect)) {
          if (horizontal) {
            if (player.vx > 0) player.x = rect.x - player.w;
            if (player.vx < 0) player.x = rect.x + rect.w;
            player.vx = 0;
          } else {
            if (player.vy > 0) {
              player.y = rect.y - player.h;
              player.vy = 0;
              player.onGround = true;
            }
            if (player.vy < 0) {
              player.y = rect.y + rect.h;
              player.vy = 0;
            }
          }
        }
      });
    }

    function getSolidRects(scene) {
      const solids = scene.platforms.slice();
      if (scene.gates) {
        scene.gates.forEach(gate => {
          if (!game.gateStates[gate.id]) solids.push(gate);
        });
      }
      return solids;
    }

    function takeDamage() {
      if (game.hearts <= 0) return;
      if (game.invuln > 0) return;
      game.hearts -= 1;
      setHUD();
      game.invuln = game.pet ? 0.9 : 0.6;
      if (game.hearts <= 0) {
        queueDialog("Try Again", "Magi Alastair takes a breather. Restarting from last checkpoint.");
        game.hearts = 3;
        respawn();
      }
    }

    function render() {
      const scene = getScene();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cam = game.camera;
      drawBackdrop(scene, cam);

      (scene.platforms || []).forEach(platform => drawPlatform(platform, cam));

      scene.gates && scene.gates.forEach(gate => {
        if (game.gateStates[gate.id]) {
          drawGate(gate, cam, true);
        } else {
          drawGate(gate, cam, false);
        }
      });

      scene.runes && scene.runes.forEach(rune => {
        if (!rune.collected) drawRune(rune, cam);
      });

      if (scene.keyItem && !scene.keyItem.collected) drawKey(scene.keyItem, cam);
      if (scene.wandItem && !scene.wandItem.collected) drawWand(scene.wandItem, cam);

      scene.checkpoints && scene.checkpoints.forEach(check => drawCheckpoint(check, cam));
      if (scene.petSpot && !game.pet) drawPet(scene.petSpot, cam);

      scene.hazards && scene.hazards.forEach(hazard => drawHazard(hazard, cam));
      scene.enemies && scene.enemies.forEach(enemy => {
        if (!enemy.defeated) drawEnemy(enemy, cam);
      });

      if (game.player) {
      drawPlayer(game.player, cam);
    }

    function drawBackdrop(scene, cam) {
      const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
      const top = scene.background ? scene.background.top : "#2a1f3d";
      const bottom = scene.background ? scene.background.bottom : "#7b4d3b";
      bg.addColorStop(0, top);
      bg.addColorStop(1, bottom);
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawSunsetGlow();
      drawFarMountains(cam);
      drawMidHills(cam);
      drawClouds(cam);

      if (scene.name === "Forest Trail") {
        drawForestSilhouette(cam);
      }
      if (scene.name === "Water Park") {
        drawWaterShimmer(cam);
      }
      if (scene.name === "Magi Tower") {
        drawTowerAura(cam);
      }
      if (scene.name === "Lodge Lobby") {
        drawLodgeBanner(cam);
      }
    }

    function drawSunsetGlow() {
      ctx.save();
      const glow = ctx.createRadialGradient(180, 120, 30, 180, 120, 260);
      glow.addColorStop(0, "rgba(255, 210, 140, 0.7)");
      glow.addColorStop(1, "rgba(255, 170, 120, 0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function drawFarMountains(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.2, 0);
      ctx.fillStyle = "rgba(58, 52, 92, 0.6)";
      ctx.beginPath();
      ctx.moveTo(-100, 420);
      ctx.lineTo(120, 280);
      ctx.lineTo(320, 420);
      ctx.lineTo(520, 300);
      ctx.lineTo(740, 430);
      ctx.lineTo(980, 290);
      ctx.lineTo(1200, 430);
      ctx.lineTo(1400, 320);
      ctx.lineTo(1700, 430);
      ctx.lineTo(1900, 360);
      ctx.lineTo(2100, 460);
      ctx.lineTo(2100, 620);
      ctx.lineTo(-100, 620);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawMidHills(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.35, 0);
      ctx.fillStyle = "rgba(70, 88, 96, 0.55)";
      ctx.beginPath();
      ctx.moveTo(-120, 500);
      ctx.quadraticCurveTo(200, 420, 420, 500);
      ctx.quadraticCurveTo(700, 400, 980, 500);
      ctx.quadraticCurveTo(1300, 430, 1600, 500);
      ctx.lineTo(2000, 620);
      ctx.lineTo(-120, 620);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawClouds(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.15, 0);
      ctx.fillStyle = "rgba(255, 255, 255, 0.65)";
      for (let i = 0; i < 5; i += 1) {
        const baseX = 80 + i * 220;
        const baseY = 90 + i * 12;
        ctx.beginPath();
        ctx.ellipse(baseX, baseY, 55, 20, 0, 0, Math.PI * 2);
        ctx.ellipse(baseX + 40, baseY + 6, 45, 16, 0, 0, Math.PI * 2);
        ctx.ellipse(baseX - 40, baseY + 8, 40, 14, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawForestSilhouette(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.4, 0);
      ctx.fillStyle = "rgba(24, 52, 40, 0.55)";
      for (let i = 0; i < 12; i += 1) {
        const x = i * 140;
        ctx.beginPath();
        ctx.moveTo(x + 10, 520);
        ctx.lineTo(x + 50, 420);
        ctx.lineTo(x + 90, 520);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    function drawWaterShimmer(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.45, 0);
      ctx.strokeStyle = "rgba(180, 220, 255, 0.4)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 10; i += 1) {
        ctx.beginPath();
        ctx.moveTo(i * 160, 500 + (i % 2) * 6);
        ctx.lineTo(i * 160 + 90, 500 + (i % 2) * 6);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawTowerAura(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.3, 0);
      const glow = ctx.createRadialGradient(900, 260, 20, 900, 260, 180);
      glow.addColorStop(0, "rgba(210, 170, 255, 0.45)");
      glow.addColorStop(1, "rgba(210, 170, 255, 0)");
      ctx.fillStyle = glow;
      ctx.fillRect(700, 120, 400, 320);
      ctx.restore();
    }

    function drawLodgeBanner(cam) {
      ctx.save();
      ctx.translate(-cam.x * 0.25, 0);
      ctx.fillStyle = "rgba(180, 90, 60, 0.5)";
      ctx.fillRect(260, 200, 220, 50);
      ctx.fillStyle = "rgba(250, 220, 160, 0.7)";
      ctx.font = "16px Trebuchet MS";
      ctx.fillText("Lodge of Runes", 280, 232);
      ctx.restore();
    }
    }
    function drawPlatform(platform, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      if (platform.type === "ground") {
        const g = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.h);
        g.addColorStop(0, "#4f6a44");
        g.addColorStop(1, "#2f4b34");
        ctx.fillStyle = g;
        ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
        ctx.fillStyle = "rgba(27, 46, 30, 0.7)";
        for (let i = 0; i < platform.w; i += 40) {
          ctx.fillRect(platform.x + i, platform.y, 20, 10);
        }
      } else if (platform.type === "wood") {
        ctx.fillStyle = "#a56634";
        ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
        ctx.strokeStyle = "#6a3b1d";
        ctx.lineWidth = 3;
        ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
        ctx.strokeStyle = "rgba(255, 222, 180, 0.3)";
        for (let x = platform.x + 10; x < platform.x + platform.w; x += 40) {
          ctx.beginPath();
          ctx.moveTo(x, platform.y + 4);
          ctx.lineTo(x + 20, platform.y + platform.h - 4);
          ctx.stroke();
        }
      } else {
        ctx.fillStyle = "#808999";
        ctx.fillRect(platform.x, platform.y, platform.w, platform.h);
        ctx.strokeStyle = "#4a4f5d";
        ctx.lineWidth = 2;
        ctx.strokeRect(platform.x, platform.y, platform.w, platform.h);
      }
      ctx.restore();
    }

    function drawGate(gate, cam, open) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = open ? "rgba(255,255,255,0.15)" : "#4d2b64";
      ctx.fillRect(gate.x, gate.y, gate.w, gate.h);
      ctx.strokeStyle = open ? "#9ad0ff" : "#f1d07a";
      ctx.lineWidth = 3;
      ctx.strokeRect(gate.x, gate.y, gate.w, gate.h);
      ctx.fillStyle = "#fff";
      ctx.font = "12px Trebuchet MS";
      ctx.fillText(gate.label, gate.x - 10, gate.y - 8);
      ctx.fillStyle = open ? "rgba(255,255,255,0.2)" : "rgba(255,220,140,0.5)";
      ctx.beginPath();
      ctx.arc(gate.x + gate.w / 2, gate.y + 22, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawRune(rune, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      const glow = ctx.createRadialGradient(rune.x + 12, rune.y + 12, 4, rune.x + 12, rune.y + 12, 18);
      glow.addColorStop(0, "rgba(210, 230, 255, 0.9)");
      glow.addColorStop(1, "rgba(122, 168, 255, 0.2)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(rune.x + 12, rune.y + 12, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#f0f7ff";
      ctx.fillRect(rune.x + 9, rune.y + 6, 6, 12);
      ctx.restore();
    }

    function drawKey(key, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = "#f4c04b";
      ctx.fillRect(key.x, key.y, 24, 10);
      ctx.fillRect(key.x + 8, key.y - 8, 8, 8);
      ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
      ctx.fillRect(key.x + 4, key.y + 2, 8, 2);
      ctx.restore();
    }

    function drawWand(wand, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.strokeStyle = "#c07bff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(wand.x, wand.y + 20);
      ctx.lineTo(wand.x + 20, wand.y);
      ctx.stroke();
      ctx.fillStyle = "#fff0b8";
      ctx.beginPath();
      ctx.arc(wand.x + 22, wand.y - 2, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawCheckpoint(check, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.fillRect(check.x, check.y, check.w, check.h);
      ctx.strokeStyle = "#fff";
      ctx.strokeRect(check.x, check.y, check.w, check.h);
      ctx.restore();
    }

    function drawPet(spot, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = "#59c29a";
      ctx.beginPath();
      ctx.arc(spot.x + 30, spot.y + 30, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#1a3b2f";
      ctx.fillRect(spot.x + 20, spot.y + 26, 6, 6);
      ctx.fillRect(spot.x + 34, spot.y + 26, 6, 6);
      ctx.fillStyle = "#f8f1d0";
      ctx.fillRect(spot.x + 26, spot.y + 38, 8, 4);
      ctx.restore();
    }

    function drawHazard(hazard, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = "#ff6b6b";
      ctx.fillRect(hazard.x, hazard.y, hazard.w, hazard.h);
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.fillRect(hazard.x + 6, hazard.y + 4, hazard.w - 12, 3);
      ctx.restore();
    }

    function drawEnemy(enemy, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = "#3c2b3a";
      ctx.fillRect(enemy.x, enemy.y, enemy.w, enemy.h);
      ctx.fillStyle = "#f0b17c";
      ctx.fillRect(enemy.x + 6, enemy.y + 8, enemy.w - 12, 8);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(enemy.x + 8, enemy.y + 12, 4, 4);
      ctx.fillRect(enemy.x + enemy.w - 12, enemy.y + 12, 4, 4);
      ctx.fillStyle = "#c65757";
      ctx.fillRect(enemy.x + 6, enemy.y + enemy.h - 6, enemy.w - 12, 4);
      ctx.restore();
    }

    function drawPlayer(player, cam) {
      ctx.save();
      ctx.translate(-cam.x, -cam.y);
      ctx.fillStyle = "#2c2a40";
      ctx.fillRect(player.x + 6, player.y + 18, player.w - 12, player.h - 18);
      ctx.fillStyle = "#6a3b1d";
      ctx.fillRect(player.x + 4, player.y + 26, player.w - 8, player.h - 26);
      ctx.fillStyle = "#3b2f5c";
      ctx.beginPath();
      ctx.moveTo(player.x, player.y + 24);
      ctx.lineTo(player.x + player.w / 2, player.y + player.h);
      ctx.lineTo(player.x + player.w, player.y + 24);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#f4d3b3";
      ctx.fillRect(player.x + 8, player.y + 6, player.w - 16, 16);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(player.x + 12, player.y + 12, 4, 4);
      ctx.fillRect(player.x + 20, player.y + 12, 4, 4);
      ctx.fillStyle = "#f5c542";
      ctx.fillRect(player.x + player.w - 6, player.y + 18, 3, 20);
      ctx.restore();
    }

    function getInteractRect(player) {
      return {
        x: player.x - 8,
        y: player.y - 8,
        w: player.w + 16,
        h: player.h + 16
      };
    }

    function handleInteraction() {
      const scene = getScene();
      const player = game.player;
      const interact = getInteractRect(player);

      if (scene.petSpot && !game.pet && rectsOverlap(interact, scene.petSpot)) {
        game.pet = "pinePup";
        scene.petSpot.prompted = true;
        queueDialog("Pine Pup", "The Pine Pup joins you, giving extra jump grace.");
        saveGame();
        return;
      }

      if (scene.gates) {
        scene.gates.forEach(gate => {
          if (rectsOverlap(interact, gate)) handleGate(scene, gate);
        });
      }

      if (scene.dialogs) {
        scene.dialogs.forEach(dialog => {
          if (rectsOverlap(interact, dialog)) {
            queueDialog(dialog.title, dialog.text);
          }
        });
      }
    }
    function tick(timestamp) {
      if (!game.lastTick) game.lastTick = timestamp;
      const dt = Math.min(0.032, (timestamp - game.lastTick) / 1000);
      game.lastTick = timestamp;

      if (!game.paused && !game.dialogActive && !game.quizActive && game.scene !== "Title") {
        update(dt);
      }
      render();
      setHUD();
      requestAnimationFrame(tick);
    }

    function init() {
      if (shouldEnableTouchControls()) {
        touchControls.style.display = "block";
      }
      overlays.title.style.display = "grid";
      try {
        overlays.continue.disabled = !localStorage.getItem("magiwolf-save");
      } catch (error) {
        overlays.continue.disabled = true;
      }
      overlays.start.addEventListener("click", () => {
        overlays.title.style.display = "none";
        resetGame();
        setHUD();
        saveGame();
      });
      overlays.continue.addEventListener("click", () => {
        if (loadGame()) {
          overlays.title.style.display = "none";
          setHUD();
        }
      });
      overlays.restart.addEventListener("click", () => {
        overlays.victory.style.display = "none";
        resetGame();
        setHUD();
      });

      document.addEventListener("keydown", (event) => {
        if (event.repeat) return;
        const key = event.key;
        if (KEYMAP[key]) INPUT[KEYMAP[key]] = true;
        if (key === " " || key === "Spacebar") {
          if (game.player) game.player.jumpBuffer = 0.12;
        }
        if (key === "p" || key === "P") {
          game.paused = !game.paused;
          overlays.pause.style.display = game.paused ? "grid" : "none";
        }
        if (key === "e" || key === "E") {
          if (game.dialogActive) {
            nextDialog();
          } else if (!game.quizActive && game.scene !== "Title") {
            handleInteraction();
          }
        }
        if (game.quizActive && ["1", "2", "3", "4"].includes(key)) {
          const idx = Number(key) - 1;
          if (game.quizHandler) game.quizHandler(idx);
        }
      });

      document.addEventListener("keyup", (event) => {
        const key = event.key;
        if (KEYMAP[key]) INPUT[KEYMAP[key]] = false;
      });

      overlays.dialog.addEventListener("pointerdown", (event) => {
        event.preventDefault();
        if (game.dialogActive) {
          nextDialog();
        }
      });
      overlays.dialog.addEventListener("touchstart", (event) => {
        event.preventDefault();
        if (game.dialogActive) {
          nextDialog();
        }
      }, { passive: false });
      document.addEventListener("pointerdown", (event) => {
        if (game.dialogActive && !game.quizActive) {
          nextDialog();
        }
      });

      setupTouchControls();

      requestAnimationFrame(tick);
    }

    init();

    function supportsTouch() {
      return ("ontouchstart" in window) || (navigator.maxTouchPoints > 0) || window.matchMedia("(pointer: coarse)").matches;
    }

    function shouldEnableTouchControls() {
      const params = new URLSearchParams(window.location.search);
      if (params.get("touch") === "1") return true;
      return supportsTouch();
    }

    function setupTouchControls() {
      if (!touchControls) return;
      const buttons = touchControls.querySelectorAll(".touch-btn");
      const activeButtons = new Map();
      const setInput = (action, isDown) => {
        if (action === "jump" && isDown && game.player) {
          game.player.jumpBuffer = 0.12;
          vibrate(20);
          return;
        }
        if (action === "interact" && isDown) {
          if (game.dialogActive) {
            nextDialog();
          } else if (!game.quizActive && game.scene !== "Title") {
            handleInteraction();
          }
          vibrate(25);
          return;
        }
        if (action === "pause" && isDown) {
          game.paused = !game.paused;
          overlays.pause.style.display = game.paused ? "grid" : "none";
          vibrate(15);
        }
      };
      buttons.forEach(button => {
        const action = button.dataset.action;
        const onDown = (event) => {
          event.preventDefault();
          activeButtons.set(event.pointerId || action, action);
          setInput(action, true);
        };
        const onUp = (event) => {
          event.preventDefault();
          activeButtons.delete(event.pointerId || action);
          setInput(action, false);
        };
        button.addEventListener("pointerdown", onDown);
        button.addEventListener("pointerup", onUp);
        button.addEventListener("pointercancel", onUp);
        button.addEventListener("pointerleave", onUp);
        button.addEventListener("touchstart", onDown, { passive: false });
        button.addEventListener("touchend", onUp, { passive: false });
      });

      setupJoystick();
    }

    function setupJoystick() {
      if (!joystick || !joystickKnob) return;
      let activeId = null;
      const maxRadius = () => joystick.clientWidth * 0.35;
      const centerFromEvent = (event) => {
        const rect = joystick.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2, rect };
      };
      const updateStick = (clientX, clientY) => {
        const { x, y, rect } = centerFromEvent();
        const dx = clientX - x;
        const dy = clientY - y;
        const radius = maxRadius();
        const dist = Math.hypot(dx, dy);
        const ratio = dist > radius ? radius / dist : 1;
        const stickX = dx * ratio;
        const stickY = dy * ratio;
        joystickKnob.style.transform = `translate(${stickX}px, ${stickY}px)`;
        const axis = clamp(stickX / radius, -1, 1);
        game.touchAxisX = axis;
      };
      const resetStick = () => {
        activeId = null;
        joystickKnob.style.transform = "translate(0, 0)";
        game.touchAxisX = 0;
      };
      joystick.addEventListener("pointerdown", (event) => {
        event.preventDefault();
        activeId = event.pointerId;
        updateStick(event.clientX, event.clientY);
        vibrate(10);
      });
      window.addEventListener("pointermove", (event) => {
        if (activeId === null || event.pointerId !== activeId) return;
        updateStick(event.clientX, event.clientY);
      });
      window.addEventListener("pointerup", (event) => {
        if (event.pointerId !== activeId) return;
        resetStick();
        vibrate(8);
      });
      window.addEventListener("pointercancel", (event) => {
        if (event.pointerId !== activeId) return;
        resetStick();
      });
    }

    function vibrate(duration) {
      if (navigator.vibrate) {
        navigator.vibrate(duration);
      }
    }
  </script>
</body>
</html>

